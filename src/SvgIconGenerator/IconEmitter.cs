using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SvgIconGenerator;

internal static class IconEmitter
{
    private const string Header =
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a tool.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------
        """;

    public static void Execute(string? projectDir, ImmutableArray<ClassInfo> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        if (string.IsNullOrEmpty(projectDir))
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.MissingProjectDirectory, Location.None));
            return;
        }

        foreach (ClassInfo classInfo in classes)
        {
            try
            {
                // Find icon folder path
                string? relativeIconFolderPath = default;
                foreach (AttributeData? attribute in classInfo.Attributes)
                {
                    if (attribute.ConstructorArguments.FirstOrDefault().Value is not string folderPath) continue;
                    relativeIconFolderPath = folderPath;
                }
                if (string.IsNullOrEmpty(relativeIconFolderPath))
                {
                    context.ReportDiagnostic(Diagnostic.Create(Diagnostics.MissingIconDirectory, classInfo.Location, classInfo.TargetSymbol.Name));
                    continue;
                }
                string iconFolderPath = Path.Combine(projectDir, relativeIconFolderPath);
                if (!Directory.Exists(iconFolderPath))
                {
                    context.ReportDiagnostic(Diagnostic.Create(Diagnostics.MissingIconDirectory, classInfo.Location, iconFolderPath));
                    continue;
                }
                List<IconInfo> icons = SvgUtils.LoadIcons(context, iconFolderPath);

                if (icons.Count == 0)
                {
                    context.ReportDiagnostic(Diagnostic.Create(Diagnostics.NoIconsFound, classInfo.Location, iconFolderPath));
                    continue;
                }

                SourceText source = GenerateIconClass(classInfo, icons);
                context.AddSource($"{classInfo.TargetSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}.g.cs", source);
            }
            catch (Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.ErrorGeneratingIcons, classInfo.Location, classInfo.TargetSymbol.Name, ex.Message));
            }
        }
    }

    private static SourceText GenerateIconClass(ClassInfo classInfo, List<IconInfo> icons)
    {
        SourceWriter cs = new();

        // Header
        cs.WriteLine(Header);
        cs.WriteLine();

        // Namespace
        cs.WriteLine($"namespace {classInfo.TargetSymbol.ContainingNamespace.ToDisplayString()}");
        cs.WriteLine('{');
        cs.PushIndentation();

        // Class
        cs.WriteLine($"partial class {classInfo.TargetSymbol.Name}");
        cs.WriteLine('{');
        cs.PushIndentation();

        foreach (IconInfo? icon in icons.OrderBy(i => i.PropertyName))
        {
            // Emit icon
            cs.WriteLine("/// <summary>");
            cs.WriteLine($"/// Icon: {icon.FileName}");
            cs.WriteLine("/// </summary>");
            cs.WriteLine($"public static readonly global::{InjectedSource.IconDto.FullName} {icon.PropertyName} = new global::{InjectedSource.IconDto.FullName}(");
            cs.PushIndentation();

            // Name parameter
            cs.WriteLine($"\"{icon.FileName}\",");

            // DefaultAttributes parameter
            cs.WriteLine("new global::System.Collections.Generic.Dictionary<string, string> {");
            cs.PushIndentation();
            foreach (KeyValuePair<string, string> kvp in icon.DefaultAttributes)
            {
                cs.WriteLine($"{{ \"{kvp.Key}\", \"{EscapeString(kvp.Value)}\" }},");
            }
            cs.PopIndentation();
            cs.WriteLine("},");

            // InnerContent parameter
            cs.WriteLine($"\"{EscapeString(icon.InnerContent)}\");");

            // End of icon
            cs.PopIndentation();
            cs.WriteLine();
        }

        cs.PopIndentation();
        cs.WriteLine("}"); // End of class

        cs.PopIndentation();
        cs.WriteLine("}"); // End of namespace

        return cs.ToSourceText();
    }

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\r", "\\r")
            .Replace("\n", "\\n")
            .Replace("\t", "\\t");
    }
}
